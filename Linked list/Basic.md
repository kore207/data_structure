### 연결리스트와 배열

#### 배열(Array)

* 가장 기본적인 자료구조인 `Array` 자료구조는, 논리적 저장 순서와 물리적 저장 순서가 일치한다. 따라서 index로 해당 원소(element)에 접근할 수 있다. 그렇기 때문에 찾고자 하는 원소의 인덱스 값을 알고 있으면 Big-O(1)에 해당 원소로 접근할 수 있다. 즉 random access 가 가능하다는 장점이 있는 것이다.

* 하지만 삭제 또는 삽입의 과정에서는 해당 원소에 접근하여 작업을 완료한뒤 (O(1)), 또 한가지의 작업을 추가적으로 해야 하기 떄문에 시간이 더 걸린다. 만약 배열의 원소 중 어느 원소를 삭제했다고 했을 떄, 배열의 연속적인 특징이 꺠지게 된다. 즉 space가 생기게 되고 채우기위해 shift 해줘야하는 비용이 발생하고 이경우의 시간 복잡도는 O(n)이 된다. 그렇기 떄문에 Array 자료구조에서 삭제기능에 대한 시각복잡도의 최악의 경우는 O(n)이 된다.

  

#### 연결리스트의 개념과 기본 동작들(1)

> * 배열의 문제점을 해결하기 위한 자료구조가 linked list이다. 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있다. 따라서 이 부분만 다른값으로 바꿔주면 삭제와 삽입을 O(1)만에 해결 할 수 있다.
> * 하지만 Linked list 역시 한 가지 문제가 있다. 원하는 위치에 삽입을 하고자 하면 원하는 위치를 search 과정에 있어서 첫번쨰 원소부터 다 확인해봐야 한다는 것이다. Array 와 달리 논리적 저장 수서와 물리적 저장 순서가 일치하지 않기 때문이다. 이것은 일단 삽입하고 정렬하는 것과 마찬가지이다. 이 과정 떄문에, 어떠한 원소를 삭제 또는 추가하고자 했을 때, 그 원소를 찾기 위해서 O(n)의 시간이 추가적으로 발생하게 된다.
> * 결국 linked list 자료구조는 search에도 O(n)의 time complexity를 갖고, 삽입 삭제에 대해서도 O(n)의 time complexity를 갖는다. 그렇다고해서 아주 쓸모없는 자료구조는 아니기에 우리가 학습하는 것이다. 이 Linked list는 Tree 구조의 근간이 되는 자료구조이며, Tree에서 사용되었을때 그 유용성이 드러난다.

* 리스트

  -기본적인 연산: 삽입, 삭제, 검색 등,

  -리스트를 구현하는 대표적인 두 가지 방법: 배열, 연결리스트

* 배열의 단점

  -크기가 고정 - reallocation 이 필요

  -리스트의 중간에 원소를 삽입하거나 삭제할 경우 다수의 데이터를 옮겨야함

* 연결리스트

  -다른 데이터의 이동없이 중간에 삽입이나 삭제가 가능

  -길이의 제한이 없음

  -하지만 랜덤 엑세스가 불가능

#### 연결리스트란?

+ 메모리에 연속된 공간에 저장된 배열과 달리 순서대로 저장할 필요가 없다.
+ 다만 첫번째 데이터에 두번째 데이터의 주소를 함께 저장한다.

